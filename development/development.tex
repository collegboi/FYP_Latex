\chapter{Development}

\label{ch:conclusions}

\section{Introduction}

As explained in the design chapter, this project includes three deliverables. So the development will include; a Mac app dashboard, Perfect web-server and CocoaPods framework. Using the "tree-shaped" methodology the web-server was split up into their separate sections which include development, testing, and run. Then each service was design, developed and testing before moving up the tree. The development then broken up into phases, this way the project can be kept on track on what has been completed and whats left to do.

\begin{enumerate}
  \item Services Development
  \item Integrate into Live App
  \item Dashboard Development
  \item CocoaPod Framework 
\end{enumerate}

As this project methodology is based on Test Driven Development (TDD) approach, the services was developed first and tested before adding to the project. Then once these services have cleared, they were integrated into the DIT-Timetable app explained later, this was to ensure how the new services were developed would pass Apples prepublish tests. Once this was accomplished, the dashboard was developed next to view the services in an interface. Then lastly the services were developed into a SDK to be used in any mobile application.

\section{Project Management}

Good software project management is essential in developing and delivery of software projects. Software development is often difficult to estimate the time required to complete the project, especially when using new technologies. Project milestones can be used to monitor the development progress of the project at certain key points. Above includes the list of the key points within the project. Each point had its own time frame; this kind of project can lead to expanding to including more services and tools, so sticking to the list will help be on schedule.

This project differs from commercial project, in that the project manager, designer, developer and tester were all the same person. And with any project, testing plays a major role in software development and can easily be left out. So self-discipline was required as there was no "boss" to answer to. 

\section{Services Development}

Each service had it's own Perfect server application along with Playground app. This made is easy to decide whether or not it was possible to implement each service into the project. For some of the services, the same Perfect web-server was used and able to be adapted to accommodate the requests needed. 

\paragraph{Setup} Before any development was started, some services was required to be setup. Perfect web-server developers provides an "assistant" to help with the setup and include and required packages needed to develop the API. The list of packages for the project include the following:

\begin{enumerate}
  \item https://github.com/PerfectlySoft/Perfect-Turnstile-MongoDB.git
  
  -Used to provide functionality to interact with MongoDB database, and provide authentication when requests come to the server.
  \item https://github.com/PerfectlySoft/Perfect-RequestLogger.git
  
  -Provides the web-server with a logging system.
  \item https://github.com/hkellaway/Gloss.git
  \item https://github.com/PerfectlySoft/Perfect-Notifications.git
  
  -Aid with the push notifications.
  \item https://github.com/PerfectlySoft/Perfect-SMTP.git
  
  -To be able to send Mails
  \item https://github.com/PerfectlySoft/Perfect-Zip.git
  
  -To zip backups folders, when sending to remote location.
\end{enumerate}

After the Perfect web-server was setup, the mongoDB was required to installed locally. This was done by running the following commands in list \ref{lst:mongodb}

\lstinputlisting[label={lst:mongodb}, language=Bash, caption=MongoDB setup]{development/code/mongo.m}


\lstinputlisting[label={lst:playground},language=Swift, caption=Playgrounds setup]{development/code/playground.m}

To be able to run asynchronous code in the playgrounds, the following lines of code in list \ref{lst:playground} is required to be added to the top of the file. This will to make asynchronous code and get results.

\subsubsection{Database storage}

The database storage section is split up into two parts of the development. 

\begin{enumerate}
  \item Object-relational mapping (ORM)
  \item Storage - how to send the objects to store persistently
\end{enumerate}

\paragraph{ORM}

The database storage required an object role model (ORM) which is a powerful method for designing and querying database models at the conceptual level, where the application is described in terms easily understood by non-technical database developers. It is a technique for converting data between incompatible type systems in object-oriented programming languages. The ORM was developed using Playground tool, where the creation of objects and parsing into JSON objects. The functionality of the ORM is to create a new object, parse it and send to the server, and be able to bring all objects back from the server.

This was developed using protocols and protocol extension. Protocols as Apple states "defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality." and extensions are "new functionality to an existing class, .., protocol type.". \cite{protocol} A protocol called TBJSONSerializable was developed as seen in listing \ref{lst:protocol_ext}

\lstinputlisting[label={lst:protocol_ext},language=Swift, caption=Protocol]{development/code/protocol_ext.m}

The first protocol TBJSONRepresentable simply states that this variable TBJSONRepresentation has to be used in any class or protocol conforming to that protocol. Inside the TBJSONSerializable protocol, we have two methods that any class or structure used throughout any mobile application will have to these two methods. The TBJSON to a type alias that is a dictionary, which holds the JSON objects which will be used when parsing. Next the protocol extension was developed, where the objects will be parsed into a dictionary type form that then can easily be parsed in JSON. In listing \ref{lst:TBJSONSerializable} illustrates how the objects are parsed.

\lstinputlisting[label={lst:TBJSONSerializable},language=Swift, caption=TBJSONSerializable]{development/code/TBJSONSerializable.m}

In listing \ref{lst:TBJSONSerializable}, the TBJSONRepresentation variable contains a switch case to loop through the mirrored; which is a representation of the sub-structure, each class property such as String, Int or Dictionary, and depending on the type be parsed into AnyObject and assigned to the dictionary with the key being the name of the variable.

The design also stated that in reprieving objects, functionality is to be in placed to parse back to objects. Using protocol extension to type alias of dictionary and method chaining, a list of functions was implemented to parse each value back to the desired type. The method chaining speeds the development time for the developer, without needing to find the correct type first. An example of this is in listing \ref{lst:tryConvert} which takes the parameter of the key, and tries to parse the value in two ways. First if the value if of type integer, it will return that value, but if it is of type String, it will convert string to integer and return the new value.

\lstinputlisting[label={lst:tryConvert},language=Swift, caption=Dictionary]{development/code/tryConvert.m}

\paragraph{Storage}

As part of the project architecture with regarding to storage, any structure should have the functionality to send to the server, and retrieve without the need to create another function to setup and communication over HTTP. As described in the design chapter, all structures conforming to the protocol will be able to send and retrieve the object/s between the server and the application. JSON is used in the transfer of data, a format in which both server and client can understand. JSON objects are simply just dictionaries where each value has an object of some type. The following table \ref{tb:object} illustrates the library commands to send and retrieve objects between the cloud storage. The T in the return column means that this function return type is of a certain type. In the following examples will be returning type TBJSONSerializable which is our protocol.

\begin{table}[!h]
\centering
\caption{My caption}
\label{tb:object}
\begin{tabular}{|c|l|c|l|}
\hline
\rowcolor{green!20}
\multicolumn{1}{|l|}{Library Method} & Description & \multicolumn{1}{l|}{Parameters}                                                       & Result            \\ \hline
getFilteredInBackground                                      & \begin{tabular}[c]{@{}l@{}}Retrieves the filtered\\ object\end{tabular} & \begin{tabular}[c]{@{}c@{}}query: {[}String:AnyObject{]}, \\ type:T.Type, \\ appKey: String = ""\end{tabular} & T Object          \\ \hline
getInBackground                                              & Retrieves the object                                                    & \begin{tabular}[c]{@{}c@{}}objectID: String, type:T.Type, \\ appKey: String = ""\end{tabular}                 & T Object          \\ \hline
removeInBackground                                           & Removes the object                                                      & objectID: String, appKey: String = ""                                                                         & Successful/ Error \\ \hline
sendInBackground                                             & \begin{tabular}[c]{@{}l@{}}Update or send the \\ object\end{tabular}    & \multicolumn{1}{l|}{objectID: String, appKey: String = ""}                                                    & Successful/ Error \\ \hline
\end{tabular}
\end{table}

The next table \ref{tb:objects} illustrates returning back array of objects.


\begin{table}[!h]
\centering
\caption{My caption}
\label{tb:objects}
\begin{tabular}{|c|l|c|l|}
\hline
\rowcolor{green!20}
\multicolumn{1}{|l|}{Library Method} & Description & \multicolumn{1}{l|}{Parameters}                                                       & Result            \\ \hline
getFilteredInBackground                                      & \begin{tabular}[c]{@{}l@{}}Retrieves the filtered\\ object\end{tabular} & \begin{tabular}[c]{@{}c@{}}query: {[}String:AnyObject{]}, \\ type:T.Type, \\ appKey: String = ""\end{tabular} & T Objects \\ \hline
getAllInBackground                                           & Retrieves the object                                                    & \begin{tabular}[c]{@{}c@{}}objectID: String, type:T.Type, \\ appKey: String = ""\end{tabular}                 & T Objects \\ \hline
\end{tabular}
\end{table}

\begin{figure}[!h]
    \caption{Storage Sequence Standard}
    \centering
    \includegraphics[width=100mm]{images/services/storage_sequence_current}
    \label{fig:storage_old}
\end{figure}


\begin{figure}[!h]
    \caption{Storage Sequence New}
    \centering
    \includegraphics[width=100mm]{images/services/storage_sequence}
    \label{fig:storage_new}
\end{figure}

The two figures \ref{fig:storage_old} and \ref{fig:storage_new} show the difference to developing the standard way, with the developing having to create a JSON parser and then set-up a HTTPS connection to send it to the server in Fig \ref{fig:storage_old} . The new way in Fig \ref{fig:storage_new} using the project's storage protocol involves the developer only having to create the object, then using the objects functionality to send it to the server.

\subsubsection{Apple Push Notifications (APNs)}

\paragraph{Server}

Push notifications requires a number of steps to be implemented. First the .p8 key was downloaded, then the Perfect server test project required accessing that file to send notifications. Using the DIT-Timetable app to receive the push notifications.  

\begin{figure}[!h]
    \caption{APNs \cite{apns}}
    \centering
    \includegraphics[width=75mm]{images/APNs}
    \label{fig:apns}
\end{figure}

In fig \ref{fig:apns} represents the stages in which to send push notifications. Inside the red box is the server layer, where the .p8 file is located, the push model is where the messages come from. The notifications goes through Apple's sandbox APNs, then on to the mobile devices.

\paragraph{Client}

APNs tool was implemented in the library, for which the developer can use the notification object to send request to the server, which in turn sends the notifications. The notifications object requires a list of values to be set for the notifications to work.

\begin{itemize}
  \item Universally Unique Identifiers
  - the targets device unique id to which apple will the notification
  \item Message
  - message which source wants to send to the target
  \item Badge Number
  - each notification can be assigned a number, which display on the app icon
  \item Title
  - the title of the notification, usually the app name
\end{itemize}

The following table \ref{table:mob_apns} demonstrates notification library to send notifications.

\begin{table}[!h]
\centering
\caption{APNS Library}
\label{table:mob_apns}
\begin{tabular}{|c|c|c|c|}
\hline
\rowcolor{green!20}
Library Method                    & Description                        & Parameters    & Result              \\ 
\hline
TBNotification.sendNotification();        & \makecell{Sends notifications\\ object to server} &  None & Successful/ Error   \\ 
\hline
\end{tabular}%
\end{table}

Fig \ref{table:apns} shows how to use the API requests outside of the library.

\begin{table}[!h]
\centering
\caption{Analytics API Requests}
\label{table:apns}
\begin{tabular}{|l|l|l|l|}
\hline
\rowcolor{green!20}
API Call                        & HTTP Method & Description                    & Parameters   \\ \hline
/\{appKey\}/notification & POST        & send notification object       & JSON Object  \\ \hline
/\{appKey\}/storage/TBNotification & GET         & Retrieves all notification objects & JSON Objects \\ \hline
\end{tabular}
\end{table}


\subsubsection{Analytics}

The first part for the analytic developed was the creation of the Perfect web-server which excepted POST requests. A playground application was developed with the lines of code in list \ref{lst:playground} to aid with HTTP requests. This class made gathers some information before sending the request, this include, time-stamp, build version, OS version, device make and model. For the purposes of testing this service, the data was hard-coded in separate function, that in turn would be reading from plist file. Some of methods and the parameters are included in the following table \ref{table:mob_analytics} shows how to use the library to send analytics. The server stores the analytic objects in the database corresponding to the application, this is done using the appKey which is sent up in the API request.

\begin{table}[!h]
\centering
\caption{Analytics Library}
\label{table:mob_analytics}
\begin{tabular}{|c|c|c|c|}
\hline
\rowcolor{green!20}
Library Method                    & Description                        & Parameters    & Result              \\ 
\hline
TBAnalytics.sendOpenApp();        & \makecell{Sends up object\\ with open app type} &   \makecell{view: UIView , \\ method: String? = \#function \\ , file: String? = \#file } & Successful/ Error   \\ 
\hline
TBAnayltics.send();               & \makecell{Send up object \\ with type as option} &  \makecell{ app: UIResponder, \\ type: SendType \\ , method: String? = \#function ,  \\ file: String? = \#file } & Successful/ Error   \\ 
\hline
 \makecell{ TBAnayltics \\.getAllInBackground(); } & \makecell{Retrieves all \\ TBAnayltic objects }   & NONE        & Array of TBAnayltics \\ 
\hline
\end{tabular}%
\end{table}

Fig \ref{table:analytics} shows how to use the API requests outside of the library.

\begin{table}[!h]
\centering
\caption{Analytics API Requests}
\label{table:analytics}
\begin{tabular}{|l|l|l|l|}
\hline
\rowcolor{green!20}
API Call                        & HTTP Method & Description                    & Parameters   \\ \hline
/\{appKey\}/storage/TBAnalytics & POST        & Uploads analytics object       & JSON Object  \\ \hline
/\{appKey\}/storage/TBAnalytics & GET         & Retrieves all analytic objects & JSON Objects \\ \hline
\end{tabular}
\end{table}


\subsubsection{Remote Configuration}

The remote configuration service development is broken up into four sections.

\begin{itemize}
  \item JSON files 
  - where the configuration objects will reside on the phone
  \item JSON file manager
  - how we will retrieve the values
  \item Objects configuration
  - how each interface object can be configured
  \item Remote change
  - will be discussed in the dashboard development
\end{itemize}

This section will discuss the first three, the remote change will be explained in dashboard development section.

\paragraph{JSON files}

The first part was the development of the JSON file layout. The design chapter already discussed the design of the remote configuration, where each class object will contain the objects relating to that class, and subsequently the objects properties will be in the object. To help with this, the storage protocol TBJSONSerializable was used to be able to parse the objects into JSON string. In listing \ref{fig:rc-cd} illustrates the class diagram for the complete remote configuration structure.

\begin{figure}[!h]
    \caption{Remote Config Class Diagram}
    \centering
    \includegraphics[width=150mm]{images/classdiagrams/config}
    \label{fig:rc-cd}
\end{figure}

In figure \ref{fig:rc-cd}, the remote configuration structure consists of 5 classes. The very first class of the structure is the Config class. This is where all the other class objects will be located. The config class holds a number of properties, the first being the colors value, where all colours used in the application will be stored. The RCColour object contains the RCG values along with alpha and the name of each colour. This name will be used in the properties of each object for example background colour. Next is controllers of type RCController, these are the main classes or commonly known as ViewControllers in the mobile app. 

Moving on to the RCController class, the properties include the name for that class which is the same name in app, the class properties so for example, if that class is of type UIViewController, that class will contain backgroundColor property etc. The last property is objectList of type RCObject. This is where all objects such as labels, text fields, tables etc will be stored. The RCObject class contains the name of the object, along with its own properties, these are what are provided by the framework when developing an app. The object type property is a type of enumeration which will contain what base class name is for example UILabel. The reason for this will be explain later in the dashboard development section.

Back to the Config class, the main setting are key value pairs that hold main data such as URLs, these are stored at this level to speed up retrieval. The language list are as the name states, contains the list of translation languages that the end user can change. This will be explained later in the language service section.

% \lstinputlisting[label={lst:config},language=Swift, caption=Configuration Structure]{development/code/config.m}

% In listing \ref{lst:config} lines 3 - 6 inclusive, holds the configuration objects for the applications. The colours objects is where all colours used in the app will be, this was placed here to speed up retrieval of each colour. The controllers objects is an array of view classes used within the app, then subsequently not shown are the objects within each class, and the properties relating to each object. The mainSettings variable on the same line of colours was placed here to speed up the retrieval of any import key values in the app such as URL. Last the languages list holds the list of languages available to the application. The languages part is based on the same as configuration files.

% Lines 8 - 13 are to distinguishes this configuration file with another, so when an update of configuration is done, then the application call tell if it has the latest or needs to download. This is to stop re-downloading the same file over and over again. The following listing \ref{table:json_manager} shows the library methods which to use the remote configuration files.

\paragraph{JSON file manager}

\begin{table}[!h]
\centering
\caption{JSON file manager}
\label{table:json_manager}
\begin{tabular}{|c|c|c|c|}
\hline
\rowcolor{green!20}
Library Method                    & Description                        & Parameters    & Result              \\ 
\hline
RCConfigManager.getColor();        & \makecell{retrieval of\\ colour} &   \makecell{ name: String, defaultColor: UIColor } & UIColor   \\ 
\hline
 \makecell{RCConfigManager\\.getTranslation(); }  & \makecell{retrieval of\\ translation value} &  \makecell{  name: String, defaultName: String  } & String  \\ 
\hline
\makecell{ RCConfigManager \\.getMainSetting(); } & \makecell{retrieves main\\ setting value  }   & \makecell{  name: String, defaultName: String } & String \\ 
\makecell{ RCConfigManager \\.getObjectProperties(); } & \makecell{retrieves object\\ properties  }   & \makecell{  className: String, objectName: String } & [String:AnyObject] \\ 
\hline
\makecell{ RCConfigManager \\.getConfigVersion(); } & \makecell{gets latest version\\ of config file  }   & None & call back method \\ 
\hline
\makecell{ RCConfigManager \\.getConfigThemeVersion(); } & \makecell{gets latest version\\ of config theme file  }   & None & call back method \\ 
\hline
\end{tabular}
\end{table}


\paragraph{Objects configuration}

Object configurations involves how to get the object properties and update the user interface (UI) object. In the design chapter, it was discussed that a protocol along with protocol extension will be used on each UI object. A separate protocol for each UI object will be developed. To do this, a protocol is first define, then an extension on that protocol to add the implementation. A snippet example of UILabel UI Object is in the following listing \ref{lst:protocol}

The extension LabelLoad is restricted for classes with type UILabel, and the developer has two methods it can use to implement. Inside the setup first, the object properties is retrieved from the JSON files, and then set to the corresponding property value.

\lstinputlisting[label={lst:protocol},language=Swift, caption=UILabel Protocol]{development/code/protocol.m}

\subsubsection{A/B Testing}

A/B Testing utilizes two other services, remote configuration and Analytics. Using the JSON files, it can tell us what version of configuration is being used, so when an analytic object is sent up, then we include the version. The server however needs some development to handle A/B Testing. The dashboard explained later is used to set what applications, version of time the testing will be done. When a request comes into the web-server for configuration file, a check on the A/B Testing list is done to check whether that app version exists as seen in figure \ref{fig:abtesting-cd}. 

\begin{figure}[!h]
    \caption{A/B Testing Class Diagram}
    \centering
    \includegraphics[width=100mm]{images/classdiagrams/ABTesting}
    \label{fig:abtesting-cd}
\end{figure}

The class diagram comprises of the ABTesting table along with the protocol TBJSONSerializable mentioned earlier. The table properties include the name of the testing, the application id and version for which that testing is part of. The versionA and versionB are the two different configuration files, and the dates for which the testing is in place.

To develop this service on the server, a singleton class "RemoteConfig" is used. When the server starts up, the singleton class is initialized with a current request number of zero. With each request, the count increases, and using this value can depend on what version of the configuration file that users gets.

% \subsubsection{Live Database}

\subsubsection{Exception catching}

The design chapter explained there are two types of exception catching, uncaught and caught exceptions. Both types need to developed in different ways, as one would potentially crash the app, so would not able to send POST request to the server. Not only are there two types of exceptions, but each exception has a different level, so when the developer views the dashboard, they can set a priority. The different levels are Fatal, Error, Warning, Info and Debug.

The exception was developed using a singleton class to that all exceptions can be sent through. When the app opens, the exception objects gets initialised which includes setting the NSSetUncaughtExceptionHandler(), where the parameter is an internal function name which looks after catching the exception. The following figure \ref{fig:exception-cd} illustrates the exception class. The tags properties holds values relating to the device type, the OS running etc, the rest of the values are in relation to the exception values.

\begin{figure}[!h]
    \caption{Exception Class Diagram}
    \centering
    \includegraphics[width=100mm]{images/classdiagrams/Exception}
    \label{fig:exception-cd}
\end{figure}

\paragraph{Uncaught exceptions}

Uncaught exceptions makes the app crashes, so between the time crash happens and the app closes which is a small window, the exception has to be dealt with. Using the NSSetUncaughtExceptionHandler() with the parameter of function, that function is not allowed to make outside calls, which include HTTP request and function calls. So the exception is stored in UserDefaults which is a built in data dictionary that stores small amount of user settings for as long as the app is stored. When the user opens application again, the exception singleton class gets instantiated, and it does a check if any exceptions exists in UserDefaults, and then a HTTP post sends the exception to the server.

\paragraph{Caught exceptions}

Using the same class as above with uncaught exceptions, extra functionality was added to enable to developers to send these exceptions to the server. As the class is a singleton and gets initialized when the application opens, the sharedClient function can be used to return the instance of that object, then use the functions available to send the exceptions.
Some of these are shown in table \ref{table:exceptions}

\begin{table}[!h]
\centering
\caption{Caught Exceptions}
\label{table:exceptions}
\begin{tabular}{|c|l|l|l|}
\hline
\rowcolor{green!20}
\multicolumn{1}{|l|}{Library Method}                             & Description                                                                                            & \multicolumn{1}{l|}{Parameters}                                                                                                        & Result            \\ \hline
\begin{tabular}[c]{@{}c@{}}MyException.\\ sharedClient.\\ captureMessage();\end{tabular} & \begin{tabular}[c]{@{}l@{}}Captures the info message \\ and sends to the server\end{tabular}           & \begin{tabular}[c]{@{}c@{}}message : String,\\ method: String? = \#function, \\ file: String? = \#file, line: Int = \#line\end{tabular}                        & Successful/ Error \\ \hline
\begin{tabular}[c]{@{}c@{}}MyException.\\ sharedClient.\\ captureMessage();\end{tabular} & \begin{tabular}[c]{@{}l@{}}Captures the message\\  along with error level\\ to the server\end{tabular} & \begin{tabular}[c]{@{}c@{}}message: String, level: ErrorLogLevel, \\ method: String? = \#function , \\ file: String? = \#file, line: Int = \#line\end{tabular} & Successful/ Error \\ \hline
\begin{tabular}[c]{@{}c@{}}MyException.\\ sharedClient.\\ captureError();\end{tabular}   & \begin{tabular}[c]{@{}l@{}}Captures the error \\ and sends to the server\end{tabular}                  & \begin{tabular}[c]{@{}c@{}}error : NSError, method: String? = \#function,\\  file: String? = \#file, line: Int = \#line\end{tabular}                           & Successful/ Error \\ \hline
\end{tabular}
\end{table}


\section{Integrate into Live App}

For some parts of project, an already developed and published app called DIT-Timetable was used to add in the services, to test if Apple would allow it through. The services include remote configuration and language choice. Due to Apple's strict guidelines, the remote configuration was developed into the DIT-Timetable app into different phases, then each stage had a build and published.

\subsubsection{Phase 1}
This phase included just the basic remote configuration, with the capability of updating text such as page title, and label values. Apple did approve this phase, and while the app live, using the iPad prototyping app the text values were able to be changed. 

\subsubsection{Phase 2}

Phase 2 gave the ability to adjust user interface values such as text colour, text size and user interaction enabling/disabling. This also been approved by Apple giving it a go ahead to be completely integrated into the project.

\subsubsection{Phase 3}

\section{Dashboard Development}

The dashboard was originally going to be created as an iPad app, but after some thought that not all mobile developers can be expected to own an iPad, the dashboard was developed as a Mac App. In the design chapter, the layout and design of the dashboard was discussed including what functionality will be provided to the developers.

Mac Application using Swift 2 was used to develop the user interface that will enabled the developer to configuration their mobile backend.

\subsection{Project structure}

Xcode IDE was used to develop the dashboard interface with help of libraries. These libraries included Cocoa(API) and Charts. Cocoa is Apple's native object-oriented application programming interface (API) for their operating system macOS. The cocoa consists of the Foundation Kit, Application Kit and Core Data frameworks. It is responsible for the appearance of apps and their responsiveness to user actions. The figure illustrates where the Cocoa frameworks resides. Charts is a third party framework provided by developer called Daniel Cohen Gindi that can be found on Github. \cite{charts} 

Already discussed in the design chapter, Apple gives an extensive section on Human Interface Guidelines on which to follow when developing Mac applications. So following these guidelines will help develop an application that can be submitted to the Mac App store. The IDE that will be used as already stated is Xcode, inside Xcode their are a number of views that can be used. In the following sections, the two main areas which will be mentioned are Interface builder and Code Editor views. The Interface Builder is where the storyboards can be edited. They are an user interface way of designing and developing the UI of an application, and the code editor view is what connects the UI view to the class files.

\begin{figure}[!h]
    \caption{Cocoa \cite{cocoa}}
    \centering
    \includegraphics[width=75mm]{images/dashboard/cocoa}
    \label{fig:apns}
\end{figure}

\subsection{Dashboard Views}

\subsubsection{Login view}

\begin{figure}[!h]
    \caption{Log in class diagram}
    \centering
    \includegraphics[width=150mm]{images/classdiagrams/Login}
    \label{fig:login_cd}
\end{figure}

Figure \ref{fig:login_cd} illustrates the class diagram for the main view controller for the log in view, as well as the staff object that were used to authenticate the user. 

In figure \ref{fig:log-in-view} illustrates the dashboard simple sign in view where the user gets verify with their credentials. The view contains three input values which the user must put in, as the server can be deployed on any server, the user is asked to put in the IP or domain name where the server is located. The other two values is user-name and password, and then there is option for the user to tick the remind me box, which keeps the user logged in. The Log-in button sends POST request to the server along with both values. A register button was decided against, as this is a restrictive application. The administrator once logged in, can create new users explained later on.

\begin{figure}[!h]
    \caption{Log-in View}
    \centering
    \includegraphics[width=75mm]{images/dashboard/login}
    \label{fig:log-in-view}
\end{figure}

\newpage
\subsubsection{Menu}

% \begin{figure}[!h]
%     \caption{Menu}
%     \includegraphics[width=50mm]{images/dashboard/menu}
%     \label{fig:menu}
% \end{figure}

% \begin{wrapfigure}{r}{0.25\textwidth} %this figure will be at the right
%     \caption{Menu}
%     \centering
%     \includegraphics[width=0.25\textwidth]{images/dashboard/menu}
%     \label{fig:menu}
% \end{wrapfigure}

Figure \ref{fig:menu} illustrates the side bar navigation. This routes the user across the whole application.

\subsubsection{Status}

\begin{figure}[!h]
    \caption{Status View}
    \centering
    \includegraphics[width=100mm]{images/dashboard/status}
    \label{fig:status-view}
\end{figure}

Figure \ref{fig:status-view} illustrated the server status view, it is the first page the user sees when entering the application. This view displays a number of graphs about the server. To help with displaying graphs, a framework was used called Charts, and figure \ref{lst:pie-chart} illustrates the code necessary to display a pie chart. 

Starting from left to right with the pie charts, the first displays the current CPU usage, next storage usage and memory usage. The line chart displays the history and current CPU usage. This gives the developer an general overview on what the physical sever doing. This can help decide whether or not to upgrade the system.

\lstinputlisting[label={lst:pie-chart},language=Swift, caption=Pie Chart]{development/code/piechart.m}

\subsubsection{Settings}

\begin{figure}[!h]
    \caption{Settings View}
    \centering
    \includegraphics[width=150mm]{images/dashboard/settings}
    \label{fig:settings-view}
\end{figure} 


\begin{figure}[!h]
    \caption{Apps Class Diagram}
    \centering
    \includegraphics[width=75mm]{images/classdiagrams/Settings}
    \label{fig:settings-cd}
\end{figure} 

Figure \ref{fig:settings-view} illustrates the settings view, where the configuration for the web-server and the mobile applications. The view is split up into three sections, the first section has some configurations values for accessing the web-server and database. The secret key, is part allows the mobile applications to access the web-server. This key is added to each request made to the API. The database user-name and password can be set, and allows for some extra security.

The notification section is for configuring the Apple Push Notifications (APNs), this has changed in the past year was mention in the design chapter. The process now has sped up how to set up the APNs on both the Apple developer console and the server. Now one key file with extension .p8 is all that is required to send APNs, this and three other values are required. Two of them are the team id, which is the developers id found in the developer console, and the key id which is provided when requesting a new .p8 key file. The Select Key buttons brings up file window, to get the file from the developers computer, and uploads the file via HTTP to the server. Once the Save button has been selected, the three values are sent to the database.

\begin{figure}[!h]
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=0.9\linewidth, height=10cm]{images/dashboard/newapp}
        \caption{App View}
        \label{fig:subim1}
    \end{subfigure}
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=0.9\linewidth, height=10cm]{images/dashboard/newversion}
        \caption{App Version}
        \label{fig:subim2}
    \end{subfigure}
\caption{Configuring Apps}
\label{fig:app-version}
\end{figure}

\begin{figure}[!h]
    \caption{iTunes API}
    \centering
    \includegraphics[width=150mm]{images/itunes-api}
    \label{fig:itunes-API}
\end{figure} 

Figure \ref{fig:settings-cd} illustrates the classes for the application and version, and Figures \ref{fig:app-version} shows where these values are displayed. Each application contains a number of properties, and some of these are provided by Apples app API. In figure \ref{fig:subim1}, the button iTunes once the user has entered the iTunes App ID field retrieves a number of values which are displayed inside the box along with the app icon. The URL for making the request is https://itunes.apple.com/lookup?id=, and the app id is passed into the GET request, and JSON objects are returned to be parsed into objects as seen in figure \ref{fig:itunes-API}. After being parsed into iTunes object, these are then set into the TBApplication class to be saved in the database.

This can only be done once the application has been published, but the other fields can be entered until then. The two important fields from this view is app key and database name, these are a security feature. Each applications gets their own database, by doing this keeps the data separate from other applications. The second security feature is the app key, this provides access to the applications database. As mentioned in the settings section, the secret is sent up each request, this is also the same with the app key. This will be discussed more in the server section later. 

In figure \ref{fig:subim2}, the developer can keep history of app versions published. The iTunes API already mentioned does not provided history of published version, so by having the feature gives the developer a history of what changes has been made in each version. This view also displays any notes and app stores images that have been added in that version. The iTunes button at the bottom left, does the same as in figure \ref{fig:subim1}, but this view retrieves different fields to be save. The reason for this button, is that when a new version is published, the app id will return the new app versions data only.

\subsubsection{Staff}

\begin{figure}[!h]
    \caption{Staff View}
    \centering
    \includegraphics[width=120mm]{images/dashboard/staff}
    \label{fig:staff}
\end{figure} 

\begin{figure}[!h]
    \caption{Edit Staff View}
    \centering
    \includegraphics[width=80mm]{images/dashboard/edit_staff}
    \label{fig:edit_staff}
\end{figure} 

The staff view displays all current staff that have been registered as can be seen in figure \ref{fig:staff}. The bar chart at the top displays the analytics of staff members logging in at a month to month basis. This view allows staff members to be added the "New Staff" button, or edit the current user by clicking the record in the table. Once click, the "Staff Member" window as illustrated in figure \ref{fig:edit_staff} is display where a number of configurations can be done. If the current staff member is of type admin, then the complete window is enabled. The typical details such as user-name and email address are asked to be entered, but the check boxes inside the box allow the user different rights. The first two columns can be unchecked to limit the user of what is displayed in the side menu. The reset password if admin be checked for a staff member if they forgot their password. 

\subsubsection{Storage}

\begin{figure}[!h]
    \caption{Storage View}
    \centering
    \includegraphics[width=120mm]{images/dashboard/storage}
    \label{fig:storage}
\end{figure}

\begin{figure}[!h]
    \caption{Storage class diagram}
    \centering
    \includegraphics[width=80mm]{images/classdiagrams/storage_class}
    \label{fig:storage_class}
\end{figure} 

Illustrated in figure \ref{fig:storage}, the tables display the database contents. The first table contains the list of databases, these are the names that are set out when setting up an application in the settings view. Next once the database name of been chosen, the list of contained collections. The table on right outputs the contents of the collection, in a parent child format. So when a cell is click, if that parent has children, then it can be expanded to show the values.

The class diagram for the storage view can be seen in figure \ref{fig:storage_class}, where both classes again conform to the TBJSONSerializable protocol. The GenericCollection is the first top class of the collection of records which are contained in the row variable. The row variable is of type Document array, where each Document properties are as follows: hasChildren for checking if that parent has children to be able to expand the row, key and value hold the values in each collection document, and last the children which contain the list of children as illustrated in figure \ref{fig:storage}. The TBAnalytics collection contains three documents, in the document there is key called "tags" which also holds children for example timeStamp.

\subsubsection{Analytics}

\begin{figure}[!h]
    \caption{Analytics View}
    \centering
    \includegraphics[width=120mm]{images/dashboard/analytics}
    \label{fig:analytics}
\end{figure}

Illustrated in figure \ref{fig:analytics} displays the analytics gathered from the different applications and versions. The drop down lists allows the developer to change where analytics was gathered from. The scroll view below contains a collection of views which display the analytics in a bar chart form. Each bar chart view is for the different types of analytic gathering, as the data gathered class diagram can be seen in figure \ref{fig:analytics_class}.

\begin{figure}[!h]
    \caption{Analytics class diagram}
    \centering
    \includegraphics[width=80mm]{images/classdiagrams/analytics_class}
    \label{fig:analytics_class}
\end{figure}

\subsubsection{Languages}

\begin{figure}[!h]
    \caption{Languages View}
    \centering
    \includegraphics[width=120mm]{images/dashboard/languages}
    \label{fig:languages}
\end{figure} 

The languages view in figure \ref{fig:languages} illustrates the layout, where the language can be selected, along with creating/updating a translation. After the mobile app and version has been chosen, if any the languages and translations will be displayed in the tables below. The first table shows the current languages which can be changed to active/inactive as required. The next table is a collection of keys (translation keys) that is available, by separating this enables the developer to see what other translations have. This will remove any discrepancy's between the translations files, e.g between English and French.

\begin{figure}[!h]
    \caption{Language class diagram}
    \centering
    \includegraphics[width=80mm]{images/classdiagrams/lang_class}
    \label{fig:lang_class}
\end{figure}

Figure \ref{fig:lang_class} shows the class diagram which is used in the Language View. The languages class holds properties include the name for example English, and if that language is available in the current selection version of the app. The language version class is where the meta-data regarding each version of translation are kept. These include the app version, the file path to the location where the language file is being stored, and if this version is published.

\subsubsection{Notifications}

\begin{figure}[. !h]
    \caption{Storage View}
    \centering
    \includegraphics[width=120mm]{images/dashboard/notifications}
    \label{fig:notification}
\end{figure}

The notification view in figure \ref{fig:notification} has two functionalities, one for view all sent notifications, and the other two send one manually. This can be done by selecting Send Push Notification button at the top right, which will bring up a new window. The fields that can be entered are what are used when sending notifications, and the two main ones are the message itself and the unique device id. The window also supports the capability of sending multiple notifications to all devices, or grouped by device type etc. The fields inside the box are optional, the title of the notification and if not set is the application name. Once the send button is pressed, a request is made to the web server to send the notifications now.

\subsubsection{Remote Configuration}

\begin{figure}[!h]
    \caption{Remote Configuration View}
    \centering
    \includegraphics[width=150mm]{images/dashboard/remote-config}
    \label{fig:remote-config-view}
\end{figure}

\begin{figure}[!h]
    \caption{Remote Configuration View}
    \centering
    \includegraphics[width=80mm]{images/classdiagrams/RemoteConfig}
    \label{fig:remote-config-cd}
\end{figure} 

The remote configuration view as illustrated in figure \ref{fig:remote-config-view} contains four tables which in turn represents the four classes already discussed in the services section \ref{fig:rc-cd}. The figure displays the current configuration for the DIT-Timetable app with version 2.4.2. When the page initially loads, the first of each drop down list to display that current configuration. The first of the drop down menus display the list of applications, which are taken from TBApplication collection. This collection are set from the settings view already discussed, along with the applications versions, which is the contents of the next drop down. The last list contains the current configuration versions as seen in table \ref{fig:remote-config-cd}. Each remote configuration object has an application and version, its relates to. The configVersion property allows A/B Testing which be discussed next to use. 

Starting from the top left table which contains the main settings values, next on the right at the colours used in that particular version in the app. The bottom left table contains the view controller or classes, and if a class contains objects the cell can be expanded to display all the objects. Once an object has been selected, the table on right contains all possible properties that can be used. This part of the dashboard also contains a JSON file, that contains all UI objects that can selected with their properties as illustrated in listing \ref{lst:label_json}. If a property options are a list type, then the raw string values are shown, for example textAlignment. In Swift, the UI object property options are type of enumeration, so when the user chooses an option the integer value is stored. When an property has been selected, either two of views will show as illustrated in figure \ref{fig:property1}. The value can then selected and set.

\lstinputlisting[label={lst:label_json}, caption=UI Object JSON]{development/code/Label_json.m}

\begin{figure}[!h]
    \caption{Edit Property View}
    \centering
    \includegraphics[width=80mm]{images/dashboard/property-1}
    \label{fig:property1}
\end{figure} 

\begin{figure}[!h]
    \caption{Save Configuration View}
    \centering
    \includegraphics[width=80mm]{images/dashboard/configuration}
    \label{fig:configuration}
\end{figure} 

Once the configuration has been set, the user has the option to save and publish that version. This can be done by pressing the Save button at the top right which displays a new window as illustrated in \ref{fig:configuration}. This view allows the user to set the version name and theme. This theme then can be used in the application for the mobile end user to choose. This will be illustrated later in the testing chapter. The live check box if unchecked can restrict this version for the mobile application to use. 

\subsubsection{AB Testing}

\begin{figure}[!h]
    \caption{AB Testing View}
    \centering
    \includegraphics[width=120mm]{images/dashboard/abtesting}
    \label{fig:abtesting-view}
\end{figure} 

\begin{figure}[!h]
    \caption{AB Testing Config View}
    \centering
    \includegraphics[width=100mm]{images/dashboard/abtesting-config}
    \label{fig:abtesting-config-view}
\end{figure} 

Figure \ref{fig:abtesting-view} illustrates the AB Testing view, and figure \ref{fig:abtesting-config-view} shows how to configure the AB Testing object. The main AB testing view displays a line chart with two line. Each line corresponds to a version that has been include that a particular testing set up as was already discussed with figure \ref{fig:abtesting-cd}. The analytical data gathered is from the TBAnalytics class that was discussed in section Analytics.

The drop down list can used to select a particular testing, and then can be view to see what configuration version had the highest usage. To configure a new A/B testing, the new button is pressed to display the new in figure \ref{fig:abtesting-config-view}. The following values are required to be set, the name, the application name, the particular version of the app and the next two drop down list are the different versions that was already configured in Remote Configuration view. The start and end time are set to allow a time frame for which these test are run. Once all the values have been entered, the push button will send the new object to the database, and when a request is made to server for a configuration file, the ab testing object will be retrieved and one of the versions will be shown. This will be discussed more in the web-server section.

\subsubsection{Backup}

\begin{figure}[!h]
    \caption{Backup View}
    \centering
    \includegraphics[width=150mm]{images/dashboard/backup}
    \label{fig:backup-view}
\end{figure} 

Figure \ref{fig:backup-view} illustrates the backup view, where completed backup of the database and files can be configured. This view offers a list of configurable values, including if backups are to be done in the first place. Once checked, the drop down list can be set to daily, weekly or a particular day of the week. Next the time of the backup can be set, then the developer has two options to save the backups locally or remotely. If locally the folder path only needs to be entered. 

Each backup folder will contain the time-tamp in the name so no overwrites will be done. After the configuration has be done, the save button will send the values to the server, and start the process. In the web-server section later, the backup web app will be discussed in detail of what happens. The table to the bottom will contain a list of backups that have been done, and by right clicking a record and clicking delete, both the record and the backup directory will be deleted. 

\subsubsection{Issues}

\begin{figure}[!h]
    \caption{Issues View}
    \centering
    \includegraphics[width=150mm]{images/dashboard/crashes}
    \label{fig:crashes-view}
\end{figure} 

\begin{figure}[!h]
    \caption{View Detailed Issue}
    \centering
    \includegraphics[width=150mm]{images/dashboard/view_crash}
    \label{fig:view-crash}
\end{figure} 

The issue view as illustrated in figure \ref{fig:crashes-view} is where all exceptions from the mobile applications can be viewed. The line chart displays the number of exceptions at a 12 month basis. This can give the developer a quick overview on how the application is doing. The exception class structure was already discussed in the services section. If the table below displays any exceptions, the record can be click to display the exception in more detail as can be seen in figure \ref{fig:view-crash}. In this window the issue can be attached to a new ticket which be discussed next.

\subsubsection{Tickets}

\begin{figure}[!h]
    \caption{Tickets View}
    \centering
    \includegraphics[width=150mm]{images/dashboard/tickets}
    \label{fig:issues-view}
\end{figure} 


\begin{figure}[!h]
    \caption{Issues Class Diagram}
    \centering
    \includegraphics[width=100mm]{images/classdiagrams/Issues}
    \label{fig:issues-cd}
\end{figure} 

Figure \ref{fig:issues-view} illustrates the tickets view page containing all different type of tickets being, bugs, features etc are displayed. After selecting the application name and version from the drop down list, the table below will get populated with the current issues relating to that application. The class diagram for each issue is illustrated in figure \ref{fig:issues-cd}, where the Issue class has the same protocol again. This give the class functionality to save and retrieve all the issues. The issue class consists of few enumeration type variables, where issue can be a bug, the issue has a status and priority. A enumeration was used to make sure of the value being parsed into the database, being only one of the values.

To be able to create a new issue, a new window was developed. This view as seen in figure \ref{fig:new-issue}.

\subsubsection{Sprint Board}

\begin{figure}[!h]
    \caption{Sprint Board View}
    \centering
    \includegraphics[width=150mm]{images/dashboard/sprint-board}
    \label{fig:sprint-board-view}
\end{figure} 

Figure \ref{fig:sprint-board-view} illustrates the sprint board view, where the tickets/issues from the previous section will show. This view gives the developer an easier layout to monitor when working through assigned tickets. The issues can also be dragged and moved into a different table, so moving an issue from in progress section to completed. The main function for this can be seen in listing \ref{lst:sprint}, which looks after moving the value into the correct table.

\lstinputlisting[label={lst:sprint},language=Swift, caption=Sprint]{development/code/sprint.m}

\section{CocoaPod Framework}

First the CocoaPod was initialised, and this was done all in command line as see in listing \ref{lst:pod_init}. The first command installs CocoaPods, then once that was installed, the pod was created. The pod lib lint creates the skeleton structure and associated files, next to create the project, pod lib create MBaaSKit was run which was followed by terminal asking for a number of inputs.

\lstinputlisting[label={lst:pod_init}, language=Bash, caption=Pod Init]{development/code/pod_init.m}

\begin{itemize}
  \item What language do you want to use?
  - Swift
  \item Do you want to include demo application?
  - Yes
  \item What testing framework do you use?
  - None (this will be done later)
  \item Do you want to view based testing?
  - No
\end{itemize}

After the pod is initialised, the .podspec files needs to be updated, so running nano MBaaSKit.podspec to edit the file. The following values are required to be updated: 

\begin{itemize}
  \item s.summary
  - a brief summary of the pod
  \item s.description
  - a brief description of the pod
  \item s.homepage
  - Github link to the location of the pod
\end{itemize}

After the pod has been setup, the next listing \ref{lst:pod_git} adds all the files, and commits to local origin repository and pushes to master.

\lstinputlisting[label={lst:pod_git}, language=Bash, caption=Pod Github]{development/code/pod_git.m}

At this stage the pod has been set up, and the initial Github commit has been pushed. 

Once the project files and code has added, the next stage was to make the pod available known as pod tagging. This was done by running the following commands in listing \ref{lst:pod_tagging}. The first command git tag "0.0.1" was run, which gives a version, then git push origin "0.0.1". After which pod spec lint MBaaSKit.podspec verifies that everything is configured correctly between where the source code is stored and the .podspec file. The output states "MBaaSKit.podspec passed validation", so the last command to push the pod can be done. 

\lstinputlisting[label={lst:pod_tagging}, language=Bash, caption=Pod Tagging]{development/code/pod_tagging.m}

\section{Web-server}

The web server developed was split up into two sections; the development of the web-server using the framework Perfect and setting up the server, and creating the installation file which will installed all the required dependency packages.

\subsubsection{Deployment}

DigitalOcean was used as server of choice and to create a virtual private servers or as DigitalOcean calls them Droplets. After creating an account and going to the page to create a droplet, the first choice was of distribution. The project required Ubuntu 16.04, after which the droplet size was asked, as for this project the basic 512MB ram, 20GB SSD Disk and 1000 GB transfer package was chosen. The next option was what region the droplet will be located and decided to go with London being the closest. Step 5 was additional options where IPv6 was chosen, for Apples requires the server to contain both IPv4 and IPv6. Step 6 was setting up SSH keys, which was done, and the last step was to give the droplet a name for the dashboard purposes.

After the droplet had been created and to log in from the computer, terminal was used with the following command: ssh root@p<droplet ip address>. Once the password had been entered, a prompt message asking to set up SSH keys and followed by entering YES. After logging in a number of steps to setup and install the required packages, while running these commands and checking they installed correctly, they were added to a script file which would be used to create the installation script.

\paragraph{Step 1}
The first step once logged in, was to create a new user and password for security purposes. This was done by running the following commands in listing \ref{lst:username}.

\lstinputlisting[label={lst:username}, language=Bash, caption=Setting user-name]{development/code/username.m}

\paragraph{Step 2}
Next the server required to set the locale along with updating and upgrading.
\lstinputlisting[label={lst:init_server}, language=Bash, caption=Updating Server]{development/code/init_server.m}

\paragraph{Step 3}
To be able to run Perfect which is Swift based, Linux server requires the Swift package
\lstinputlisting[label={lst:swift_install}, language=Bash, caption=Swift Installation]{development/code/swift_install.m}

\paragraph{Step 4}
MongoDB for persistent storage also required to be installed
\lstinputlisting[label={lst:mongo_install}, language=Bash, caption=MongoDB Installation]{development/code/mongo_install.m}

\paragraph{Step 5}
Supervisor is a service that can be installed to monitor and manage a program that is defined in the configuration file.The following listing \ref{lst:supervisor} will set up GIT which is where the web-server will be installed, and then supervisor will be installed and set-up.
\lstinputlisting[label={lst:supervisor}, language=Bash, caption=Supervisor]{development/code/supervisord.m}
At line 6 where the nano command is ran, the post-recieve files needs to be updated to contain the project name.

\paragraph{Step 6}
Next the web-server itself needs to pulled from Github and then built. Once the build has been done, ownership for the folders need to changed. Then the built packages need to be moved into the running folder, which supervisor will pick up the server and start it.
\lstinputlisting[label={lst:web-server}, language=Bash, caption=Web-Server]{development/code/web-server.m}

\paragraph{Step 7}
For the web-server to be access from the outside the server, a server needs to be installed to route the requests to the web-server. Nginx is installed and then some configurations needs to be done. When running line 3 in listing \ref{lst:server}, the port number needs to be updated to 8181 which is what the web-server runs on. Nginx will route traffic coming in at 80 and 443 which is HTTP and HTTPS to port 8181.
\lstinputlisting[label={lst:server}, language=Bash, caption=Nginx Server]{development/code/nginx_setup.m}

\subsubsection{Development}

To start developing the server, Perfect provides a basic template with just the structure to start off with, found at https://github.com/PerfectlySoft/PerfectTemplate. A new directory was created, then running the command git clone https://github.com/PerfectlySoft/PerfectTemplate.git. One the template was download, running the following command would create an Xcode project: swift package generate-xcodeproj. The package.swift file required updating with the required packages such as MongoDB and Notifications etc, then running the command sudo swift build inside the project directory retrieved all the packages that was included in the package.swift file. The project structure contains sources and packages directories, the packages are which was already downloaded and the sources where the web-server files are placed. 

The web-server starts off with the main.swift which includes the creation the HTTP server, and adding routes and setting the port number, then starting the server. The routes are where each REST request will go, so for example if request /user then the route will go to the user class. An example of the routes is shown in listing \ref{lst:routes}. This example is the routes for the database, retrieving and sending object. The function is called from the main.swift file, which returns all the routes for the database handler class. The handler parameter is the method name in the same class for which implementation is done depending on the route.

\lstinputlisting[label={lst:routes},language=Swift, caption=Routes]{development/code/routes.m}
% Instead of creating a new app for each service as already mentioned before which does not follow the programming principle "Only write it once".

The web-server deliverable consists of a number of apps, these apps is a web application that does something e.g. database of records. The design chapter under web-server section discussed the overview structure, and what apps to developed. This section will go into detail for each app, what functionality is required.

\paragraph{Database}

\begin{figure}[!h]
    \caption{Database Sequence Diagram}
    \centering
    \includegraphics[width=150mm]{images/sequence/Database}
    \label{fig:database-seq}
\end{figure} 

The database app consists of four layers; the routes, authentication, service and the database as can be seen in figure \ref{fig:database-seq} This allows the app to be loosely coupled meaning if the database type later can easily be changed without having to change the other layers. The objective of this app is to perform the four basic functions of persistent storage; create, read update and delete (CRUD). So the first four routes were developed, and the collection name was required to be passed as parameter as this is a generic app, the collection names would not be known until the developer creates them. This is show in table \ref{tb:db-routes}, where the app key is also passed to be authenticated. 

\begin{table}[!h]
\centering
\caption{Database routes}
\label{tb:db-routes}
\begin{tabular}{|l|l|}
\hline
\rowcolor{green!20}
Route                                  & HTTP Method \\ \hline
/api/\{appkey\}/storage/\{collection\} & GET         \\ \hline
/api/\{appkey\}/storage/\{collection\} & POST        \\ \hline
/api/\{appkey\}/storage/\{collection\} & DELETE      \\ \hline
\end{tabular}
\end{table}

The database service layer function is called depending on the route, the service layer will then communicate with the database class to perform the task. The database class performs five steps for each of the CRUD operations;

\begin{itemize}
  \item Open client connection
  - the connection being the Uniform Resource Identifier (URI) : "mongodb://localhost:27017" 
  \item Database 
  - connect to correct database depending on the application
  \item Collection
  - get the collection from the collection name which is passed in
  \item Find
  - run the query and pass in any where clauses if required
  \item Close
  - close the collection, then database and finally the client
\end{itemize}

Once these steps have finished, the function returns the search records, which in returns parses the records into JSON form to be sent back in the response object. After the four basic functions were completed, extra functionality was added to be able to pass query dictionary from the mobile application for example "{"name":"tim"}" which will return all records where name key contains values equal to "tim". This was developed by creating another route along with function which accepts the dictionary query and includes this in the find function.

Next the routes had to be included for the dashboard to make requests, for example to retrieve all databases and in turn all collections relating to each database. This is used in the database page called Storage already discussed above. 

\paragraph{File}

\begin{figure}[!h]
    \caption{File Sequence Diagram}
    \centering
    \includegraphics[width=150mm]{images/sequence/FileController}
    \label{fig:file-seq}
\end{figure}

This app provides two purposes, one for uploading of files of any type and storing from the mobile app, as well as other web apps such as Remote Config discussed next to retrieved a stored file. The figure \ref{fig:file-seq} illustrates the steps required to manage files. The difference between singleton class and normal class, is that only one instance is made upon run time, this helps controller file writing, so that two instances are not trying to write to the same file at the same time.

\begin{table}[!h]
\centering
\caption{File Handler Routes}
\label{tb:file-routes}
\begin{tabular}{|l|l|}
\hline
\rowcolor{green!20}
Route                                        & HTTP Method \\ \hline
/api/\{appkey\}/upload/\{directory\}/          & POST        \\ \hline
/api/\{appkey\}/upload/\{filepath\}/ & GET         \\ \hline
\end{tabular}
\end{table}


The routes to handler send and retrieving files as show in table \ref{tb:file-routes}. The post route sends up the files to a particular directory path which is set from the client application side, as well as the file names. After the file handler has successfully saved the files in the specified directory, the file controller class calls the database service class and inserts the files that has been upload as history records. 

This structure for the file web app allows the access from other apps such as the remote configuration and language to access the singleton file class. Inside the file class, there are a number of functionalities required such as setting the working directory. This is another reason for using the singleton pattern, as every time the working directory is called, it creates a new directory which would cause files to be lost in a multitude of sub-folders. The instantiation of the file class happens when the server starts up in the main.swift file, thus given all over apps access to one working directory.

Extra functionality that was required is if a file path does not exist, then the directories need to be created. An example of this would be if file path was "/files/cars/image1.PNG", and the cars directory currently did not exists then a number of steps is required to ensure the file location was correct.

\begin{enumerate}
  \item check if the path exists
  - if true then overwrite 
  \item if path does not exit
  - get directory path from file path string = "/files/cars/" 
  \item create file path
  \item save file to location
\end{enumerate}


\paragraph{Remote Configuration}

\begin{figure}[!h]
    \caption{Remote Config Sequence Diagram}
    \centering
    \includegraphics[width=150mm]{images/sequence/RemoteConfig}
    \label{fig:rc-seq}
\end{figure}

\begin{table}[!h]
\centering
\caption{Remote Config Routes}
\label{tb:rc-routes}
\begin{tabular}{|l|l|}
\hline
\rowcolor{green!20}
Route                                        & HTTP Method \\ \hline
/api/\{appkey\}/remote                       & POST        \\ \hline
/api/\{appkey\}/remote/\{version\}           & GET         \\ \hline
/api/\{appkey\}/remote/\{version\}/\{theme\} & GET         \\ \hline
\end{tabular}
\end{table}

As illustrated in figure \ref{fig:rc-seq} to retrieve the configuration file contents, there are a number of steps. The HTTP GET request with the correct route seen in table \ref{tb:rc-routes} is made, then the app key is again authenticated, if passed the RCController class is called to get a version file. The RCController makes a call to the database service class for the collection of remote configuration along with the query of the app version. The record is returned with a file path, then file controller class is called to return the contents of the file. 

\begin{figure}[!h]
    \caption{A/B Testing Sequence Diagram}
    \centering
    \includegraphics[width=150mm]{images/sequence/ABTesting}
    \label{fig:ab-seq}
\end{figure} 

The A/B Testing service discussed in the services section above requires extra functionality, this is illustrated in figure \ref{fig:ab-seq}. As can be seen in the RCController class, an extra query to the database service to get the records if any of A/B Testing. The A/B Testing records contain the application version which is query from the version passed in, if the return contains a record then a request to it self is made to get the request number. This request number is the number of requested modular 2, so depending on the number depends on what version A or B is returned to the response body. The RCController class is a singleton, meaning it only has one instance, this was used to store the request no, instead of writing to a text file which would cause performance issues. 

\paragraph{Authentication}

\begin{figure}[!h]
    \caption{Authentication Sequence Diagram}
    \centering
    \includegraphics[width=150mm]{images/sequence/Authenticate}
    \label{fig:authenticate-seq}
\end{figure}

Figure \ref{fig:authenticate-seq} illustrates the required steps to authenticate a user when signing in. The HTTP request method is POST to keep both user-name and password out of URL for security purposes. The authentication handler class which handles the routes, passes the values to the authentication controller class which performs four steps. The first step is to ensure the user exist using the user-name, next it does a check if the password reset field has been set to 1 meaning the administrator has authorized this account for the password to be changed. If the result is true, the message is sent back to the client app for the developer to allow the user to change the password. If the reset password flag has not been sent, then the password is first encrypted using the salt value used when registering. 

The salt value is stored in a separate table for security reasons, and is a one way hashing function. The primary reason for using salt, is to defend against dictionary attacks, historically a password would of been stored in plain-text but overtime additional steps were in placed to safeguard the password and one these ways is called Salt. After the password has been salted, then the query can be run by passing the user-name and hashed password and if there returns one record then the client app is sent an authentication message. 

\paragraph{System}

The system handler and controller class are for the dashboard status view, the data for the four pie charts being CPU, memory and storage usage. This data is retrieved by running Linux commands from the server. The overview structure of this web app includes the system handler with only handles a get request for retrieving all the required data. The system controller class includes a number of functions with each pie chart data in each, which is shown in table \ref{tb:system} along with the command and output. 

\begin{table}[!h]
\centering
\caption{My caption}
\label{tb:system}
\begin{tabular}{|l|l|l|}
\hline
\rowcolor{green!20}
Function name    & Linux command & Values retrieved       \\ \hline
getCPUUsuage()     & top -bn1      & user, system, idle     \\ \hline
getMemoryUsuage()  & free -m       & total, used, available \\ \hline
getStorageUsuage() & df -h         & size, used, available  \\ \hline
\end{tabular}
\end{table}

The CPU usage is retrieved by running the "top" which displays all Linux tasks, the "-b" option puts the top in batch mode operation. The batch mode stops top from accepting any input until top has exited.The "-n1" is the number of iterations or frames to be run before ending, in this cause one. The output is then parsed into a dictionary for user, system and idle. 
The "free" command displays the amount of free and used memory in the system. The "-m" option displays the output in MBs format. The result creates a number of columns, and the string is parsed and the total, used and free values are appended to the dictionary. 
The "df" command gets a report of the file system disk space usage, and using the -h options returns the result in human readable format e.g 1K, 512M 2GB. After the three commands are run, the result is sent back to the response body parsed in JSON format.

\paragraph{Backup}

\begin{figure}[!h]
    \caption{Backup Sequence Diagram}
    \centering
    \includegraphics[width=150mm]{images/sequence/backup}
    \label{fig:backup-s}
\end{figure}

The backup feature discussed in the dashboard sections requires the web-server to a complete backup of all database collections and files to a remote or local location. The sequence diagram in figure \ref{fig:backup-s} illustrates the steps required to accomplish this. The sequence diagrams displays two types of requests, if a backup is requested to be done now or scheduled for later time. The first is quite simple with the request coming in and passed to the backup controller class, and performs the required steps to accomplish the backup while will be discussed after.

First with scheduling a backup requires a few more steps, the Jobs class is a singleton which keeps an instance of the CronJob class. CronJobSwift is a package provided by developer called Ryan Collins with Github link "https://github.com/rymcol/SwiftCron-Example". The CronJob is on the same principle of Linux software utility called Cron which is a time-based job scheduler. These jobs can be run repeatedly at certain times of the day, week etc to perform tasks in the background with the developer. The CronJob class still requires to be kept running, and outside of the main.swift file to be updated with new jobs or cancelling jobs. The singleton pattern is used to keep an instance of CronJob running, and allow outside requests to update the jobs. 

Back to the sequence diagram \ref{fig:backup-s}, the make instance method is only a fail safe if the main file when the server starts up does not create the instance. When the instance is return back to the backup controller class, the job can be created and updated. All scheduled jobs are also stored in the database along with the job id, so that a request can be made to cancel a particular job.

Once the backup method has been called, a number of steps are required along with a package called Zip provided by Perfect. A Linux package is also required by running the following command "apt-get install libminizip-dev". The package for Swift zip can be found at the Github link https://github.com/PerfectlySoft/Perfect-Zip. The zip package will be used to put all the collections into one zipped folder so that it can stored locally or remotely without potentially using up a lot of space.

\begin{enumerate}
  \item get list of database 
  \item get list of collections from each database
  \item stored the collections in a backup folder, sub-folded the collection name
  \item zip the backup folder with the current date
  \item move the zip folder to destination
  \item put history of the backup in the database
\end{enumerate}

\paragraph{Translations}


\begin{figure}[!h]
    \caption{Translation Sequence Diagram}
    \centering
    \includegraphics[width=150mm]{images/sequence/translation}
    \label{fig:translation-s}
\end{figure}

\begin{table}[!h]
\centering
\caption{Translation Routes}
\label{tb:translation-routes}
\begin{tabular}{|l|l|}
\hline
\rowcolor{green!20}
Route                                        & HTTP Method \\ \hline
/api/\{appkey\}/translation                  & POST        \\ \hline
/api/\{appkey\}/translation/\{language\}/\{version\}           & GET         \\ \hline
/api/\{appkey\}/translationVersion/\{language\}/\{langversion\} & GET         \\ \hline
\end{tabular}
\end{table}

The last web app to be developed is translation, which handles posting and retrieving the correct translation version and language. The table \ref{tb:translation-routes} illustrates the routes, where the first post request will send the language to both the database and file location. When a request is made for a translation file, an extra check is done to see if that version is available; this can be see in the sequence diagram in figure \ref{fig:translation-s} This was discussed in the dashboard section, where the developer has the option of making a translation version live.

The translation and configuration files availability are put into the top object of any database GET request sent to the server. Listing \ref{lst:header_json} displays the header of an object when making a request, the current version and date of what is available on the server for both configuration and translation, then the application can make a request for the latest if required.

\lstinputlisting[label={lst:header_json}, caption=Header JSON]{development/code/header_json.m}

\section{Code Stats}

\begin{table}[!h]
\centering
\caption{Project Code Stats}
\label{my-label}
\begin{tabular}{|l|l|l|}
\hline
\rowcolor{green!20}
Deliverable & Files & Code   \\ \hline
Server      & 33    & 2,663  \\ \hline
Dashboard   & 264   & 27,507 \\ \hline
SDK         & 36    & 2,271  \\ \hline
Total       & 333   & 29,778 \\ \hline
\end{tabular}
\end{table}